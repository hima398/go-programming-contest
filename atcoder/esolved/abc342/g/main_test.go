package main

import (
	"reflect"
	"testing"
)

func Test_solve(t *testing.T) {
	type args struct {
		n   int
		a   []int
		q   int
		t   []int
		l   []int
		r   []int
		x   []int
		idx []int
	}
	tests := []struct {
		name string
		args args
		want []int
	}{
		// TODO: Add test cases.
		{"Sample 1",
			args{
				6,
				[]int{2, 7, 1, 8, 2, 8},
				15,
				[]int{3, 3, 3, 1, 3, 3, 3, 1, 3, 3, 3, 2, 3, 3, 3},
				[]int{0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0},
				[]int{0, 0, 0, 5, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0},
				[]int{0, 0, 0, 4, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0},
				[]int{1, 3, 4, 0, 1, 3, 4, 0, 1, 3, 4, 4, 1, 3, 4},
			},
			[]int{2, 1, 8, 4, 4, 8, 4, 9, 9, 2, 9, 9}},
		{"Sample 2",
			args{
				24,
				[]int{721, 78, 541, 256, 970, 478, 370, 467, 344, 542, 43, 166, 619, 17, 592, 222, 983, 729, 338, 747, 62, 452, 815, 838},
				35,
				[]int{3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 3, 3, 2, 3, 1, 2, 3, 1, 3, 2, 3, 3, 3, 2, 1, 3, 3, 3},
				[]int{0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 8, 0, 0, 0, 0, 5, 0, 0, 23, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0},
				[]int{0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 23, 0, 0, 0, 0, 18, 0, 0, 23, 0, 0, 0, 0, 0, 0, 22, 0, 0, 0},
				[]int{0, 0, 0, 0, 0, 251, 0, 0, 0, 0, 0, 0, 0, 0, 0, 883, 212, 0, 0, 0, 0, 914, 0, 0, 56, 0, 0, 0, 0, 0, 0, 308, 0, 0, 0},
				[]int{10, 8, 8, 13, 9, 0, 3, 19, 13, 22, 1, 15, 18, 10, 15, 0, 0, 5, 13, 6, 15, 0, 17, 20, 0, 13, 25, 13, 13, 10, 16, 0, 19, 17, 7},
			},
			[]int{542, 467, 467, 619, 344, 541, 338, 619, 452, 721, 592, 729, 542, 592, 970, 619, 592, 747, 914, 914, 914, 914, 338, 983, 914}},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := solve(tt.args.n, tt.args.a, tt.args.q, tt.args.t, tt.args.l, tt.args.r, tt.args.x, tt.args.idx); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("solve() = %v, want %v", got, tt.want)
			}
		})
	}
}
